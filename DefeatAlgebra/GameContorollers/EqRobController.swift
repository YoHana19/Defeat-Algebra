//
//  EqRobController.swift
//  DefeatAlgebra
//
//  Created by yo hanashima on 2018/07/15.
//  Copyright Â© 2018 yo hanashima. All rights reserved.
//

import Foundation
import SpriteKit

struct EqRobController {
    public static var gameScene: GameScene!
    public static var eqRobOriginPos: CGPoint!
    private static var lines = [SKShapeNode]()
    private static var isPerfect = false
    public static var selectedEnemies = [Enemy]()
    public static var sameVeEnemies = [Enemy]()
    private static var selectedEnemyIndex: Int = 0
    private static var attackingEnemyIndex: Int = 0
    private static var instructedEnemy: Enemy?
    private static var doctorOffPos = CGPoint(x: -200, y: 170)
    private static var doctorOnPos: [CGPoint] = [
        CGPoint(x: 150, y: 170),
        CGPoint(x: 90, y: 100),
        CGPoint(x: 150, y: -370)
    ]
    private static var doctorScale: [CGFloat] = [
        0.85,
        0.6,
        0.75
    ]
    
    public static func execute(_ index: Int, enemy: Enemy?) {
        switch index {
        case 0:
            showInputPanelWithDoctor()
            break;
        case 1:
            showSelectionPanelWithDoctor()
            break;
        case 2:
            setSelectedEnemyOnPanel(enemy: enemy!)
            break;
        case 3:
            isPerfect = eqRobGoToAttack()
            break;
        case 4:
            instruction()
            break;
        case 5:
            tellCharging()
            break;
        case 6:
            if EqRobTouchController.state == .Dead {
                tellReborn()
            } else if EqRobTouchController.state == .Charging {
                tellChargeDone()
            }
            break;
        default:
            break;
        }
    }
    
    public static func back(_ index: Int) {
        switch index {
        case 0:
            guard EqRobTouchController.state == .Pending else { return }
            hideInputPanelWithDoctor()
            break;
        case 1:
            resetSelectedEnemyOnPanel()
            break;
        case 2:
            resetAll()
            break;
        case 3:
            allDone()
            break;
        case 4:
            goBack()
            break;
        default:
            break;
        }
    }
    
    private static func showInputPanelWithDoctor() {
        resetAll()
        showInputPanel()
        gameScene.eqRob.stopAction()
        gameScene.eqRob.go(to: gameScene.inputPanel.eqRobPoint, completion: {
            gameScene.eqRob.rotateForever()
        })
        CharacterController.doctor.setScale(doctorScale[0])
        CharacterController.doctor.balloon.isHidden = false
        doctorSays(in: .WillInput, value: nil)
        CharacterController.doctor.move(from: doctorOffPos, to: doctorOnPos[0])
    }
    
    private static func hideInputPanelWithDoctor() {
        hideInputPanel()
        EqRobTouchController.state = .Ready
        gameScene.eqRob.stopAction()
        gameScene.eqRob.go(toPos: eqRobOriginPos) {
            let rotate = SKAction.rotate(toAngle: .pi * -1/2, duration: 1.0)
            gameScene.eqRob.run(rotate)
        }
        CharacterController.doctor.setScale(1)
        CharacterController.doctor.balloon.isHidden = true
        CharacterController.doctor.move(from: nil, to: doctorOffPos)
    }
    
    private static func showSelectionPanelWithDoctor() {
        hideInputPanel()
        showSelectionPanel()
        gameScene.eqRob.stopAction()
        gameScene.eqRob.go(toPos: eqRobOriginPos) {
            EqRobTouchController.state = .Attack
            let rotate = SKAction.rotate(toAngle: .pi * -1/2, duration: 1.0)
            gameScene.eqRob.run(rotate)
        }
        CharacterController.doctor.setScale(doctorScale[1])
        doctorSays(in: .WillSelectEnemies, value: gameScene.inputPanel.confirmedVE)
        gameScene.selectionPanel.veLabel.text = gameScene.inputPanel.confirmedVE
        CharacterController.doctor.move(from: nil, to: doctorOnPos[1])
    }
    
    private static func setSelectedEnemyOnPanel(enemy: Enemy) {
        guard selectedEnemyIndex < 8 else {
            doctorSays(in: .WarnSelection, value: nil)
            return
        }
        doctorSays(in: .SelectingEnemies, value: nil)
        if selectedEnemyIndex < 1 {
            drawLine(start: gameScene.eqRob.absolutePos(), end: enemy.absolutePos())
        } else {
            drawLine(start: selectedEnemies[selectedEnemyIndex-1].absolutePos(), end: enemy.absolutePos())
        }
        selectedEnemies.append(enemy)
        gameScene.selectionPanel.setSelectedEnemy(target: enemy, index: selectedEnemyIndex)
        selectedEnemyIndex += 1
    }
    
    private static func resetSelectedEnemyOnPanel() {
        lines.forEach { $0.removeFromParent() }
        selectedEnemies.forEach { $0.isSelectedForEqRob = false }
        selectedEnemyIndex = 0
        doctorSays(in: .WillSelectEnemies, value: gameScene.inputPanel.confirmedVE)
        selectedEnemies = [Enemy]()
        lines = [SKShapeNode]()
        gameScene.selectionPanel.resetAllEnemies()
    }
    
    private static func eqRobGoToAttack() -> Bool {
        doctorSays(in: .EqRobGo, value: nil)
        eqRobAttackFirst(selectedEnemies[0])
        gameScene.selectionPanel.againButton.isHidden = true
        sameVeEnemies = gameScene.gridNode.enemyArray.filter { $0.vECategory == gameScene.eqRob.veCategory }
        if sameVeEnemies.count == selectedEnemies.count {
            return true
        } else {
            return false
        }
    }
    
    private static func eqRobAttackFirst(_ target: Enemy) {
        lines[attackingEnemyIndex].removeFromParent()
        if gameScene.eqRob.veCategory == target.vECategory {
            if attackingEnemyIndex < selectedEnemies.count-1 {
                gameScene.eqRob.kill(target) {
                    gameScene.selectionPanel.putCrossOnEnemyOnPanel(index: attackingEnemyIndex)
                    attackingEnemyIndex += 1
                    eqRobAttackNext(selectedEnemies[attackingEnemyIndex])
                }
            } else {
                gameScene.eqRob.kill(target) {
                    gameScene.selectionPanel.putCrossOnEnemyOnPanel(index: attackingEnemyIndex)
                    attackDone()
                    gameScene.eqRob.go(toPos: eqRobOriginPos) {
                        let rotate = SKAction.rotate(toAngle: .pi * -1/2, duration: 1.0)
                        gameScene.eqRob.run(rotate)
                    }
                }
            }
        } else {
            gameScene.eqRob.killed(target) {
                eqRobDead(enemy: target)
            }
        }
    }
    
    private static func eqRobAttackNext(_ target: Enemy) {
        lines[attackingEnemyIndex].removeFromParent()
        if gameScene.eqRob.veCategory == target.vECategory {
            if attackingEnemyIndex < selectedEnemies.count-1 {
                gameScene.eqRob.kill(target) {
                    gameScene.selectionPanel.putCrossOnEnemyOnPanel(index: attackingEnemyIndex)
                    attackingEnemyIndex += 1
                    eqRobAttackNext(selectedEnemies[attackingEnemyIndex])
                }
            } else {
                gameScene.eqRob.kill(target) {
                    gameScene.selectionPanel.putCrossOnEnemyOnPanel(index: attackingEnemyIndex)
                    attackDone()
                    gameScene.eqRob.go(toPos: eqRobOriginPos) {
                        let rotate = SKAction.rotate(toAngle: .pi * -1/2, duration: 1.0)
                        gameScene.eqRob.run(rotate)
                    }
                }
            }
        } else {
            gameScene.eqRob.killed(target) {
                eqRobDead(enemy: target)
            }
        }
    }
    
    private static func eqRobDead(enemy: Enemy) {
        lines.forEach { $0.removeFromParent() }
        doctorSays(in: .EqRobDestroyed, value: nil)
        EqRobTouchController.state = .DeadInstruction
        makeInsturctionForKilled(enemy: enemy)
        instructedEnemy = enemy
    }
    
    private static func makeInsturctionForKilled(enemy: Enemy) {
        let enemyPos = enemy.absolutePos()
        if enemy.positionY < 6 {
            let panelPos = CGPoint(x: gameScene.size.width/2-gameScene.selectionPanel.texture!.size().width/2, y: enemyPos.y+gameScene.selectionPanel.texture!.size().height+90)
            let doctorPos = CGPoint(x: doctorOnPos[2].x, y: panelPos.y+doctorOnPos[2].y)
            enemy.pointing()
            gameScene.selectionPanel.setInstruction(enemyVe: enemy.variableExpressionString)
            gameScene.selectionPanel.moveWithScaling(to: panelPos, value: 1) {}
            CharacterController.doctor.changeBalloonTexture(index: 1)
            CharacterController.doctor.moveWithScaling(to: doctorPos, value: doctorScale[2], duration: 2.0) {
                doctorSays(in: .DestroyedInstruction, value: EqRobLines.setSubLineForDestroyedInstruction(enemy: enemy, eqRob: gameScene.eqRob, eqRobVe: gameScene.selectionPanel.veLabel.text!))
            }
        } else {
            let panelPos = CGPoint(x: gameScene.size.width/2-gameScene.selectionPanel.texture!.size().width/2, y: enemyPos.y-65)
            let doctorPos = CGPoint(x: doctorOnPos[2].x, y: panelPos.y+doctorOnPos[2].y)
            enemy.pointing()
            gameScene.selectionPanel.setInstruction(enemyVe: enemy.variableExpressionString)
            gameScene.selectionPanel.moveWithScaling(to: panelPos, value: 1) {}
            CharacterController.doctor.changeBalloonTexture(index: 1)
            CharacterController.doctor.moveWithScaling(to: doctorPos, value: doctorScale[2], duration: 2.0) {
                print(EqRobLines.curIndex)
                doctorSays(in: .DestroyedInstruction, value: EqRobLines.setSubLineForDestroyedInstruction(enemy: enemy, eqRob: gameScene.eqRob, eqRobVe: gameScene.selectionPanel.veLabel.text!))
            }
        }
    }
    
    private static func setDemoCalculation() {
        gameScene.selectionPanel.setXVlaue(value: String(EqRobLines.selectedRand))
        gameScene.selectionPanel.instructedEnemy.showCalculation(value: EqRobLines.selectedRand)
        gameScene.selectionPanel.instructedEqRob.showCalculation(value: EqRobLines.selectedRand)
    }
    
    private static func attackDone() {
        if isPerfect {
            doctorSays(in: .PerfectKill, value: nil)
        } else {
            doctorSays(in: .MissEnemies, value: nil)
        }
        let wait = SKAction.wait(forDuration: 3.0)
        gameScene.run(wait, completion: {
            if isPerfect {
                back(3)
            } else {
                pointingMissedEnemies()
            }
        })
    }
    
    private static func pointingMissedEnemies() {
        var missedEnemies = sameVeEnemies.filter { !self.selectedEnemies.contains($0) }
        missedEnemies.forEach { $0.pointing() }
        if missedEnemies.count < 2 {
            instructedEnemy = missedEnemies[0]
            doctorSays(in: .MissEnemiesInstruction, value: EqRobLines.setSubLineForMissEnemiesInstruction(enemy: instructedEnemy!, eqRob: gameScene.eqRob, eqRobVe: "ãã®æµ"))
        } else {
            missedEnemies.sort { $0.variableExpressionString.count > $1.variableExpressionString.count }
            instructedEnemy = missedEnemies[0]
            doctorSays(in: .MissEnemiesInstruction, value: EqRobLines.setSubLineForMissEnemiesInstruction(enemy: instructedEnemy!, eqRob: gameScene.eqRob, eqRobVe: "ãããã®æµ"))
        }
        EqRobTouchController.state = .AliveInstruction
    }
    
    private static func makeInsturctionForMiss(enemy: Enemy) {
        let enemyPos = enemy.absolutePos()
        gameScene.gridNode.enemyArray.forEach { $0.removePointing() }
        instructedEnemy?.pointing()
        if enemy.positionY < 6 {
            let panelPos = CGPoint(x: gameScene.size.width/2-gameScene.selectionPanel.texture!.size().width/2, y: enemyPos.y+gameScene.selectionPanel.texture!.size().height+90)
            let doctorPos = CGPoint(x: doctorOnPos[2].x, y: panelPos.y+doctorOnPos[2].y)
            gameScene.selectionPanel.setInstruction(enemyVe: enemy.variableExpressionString)
            gameScene.selectionPanel.moveWithScaling(to: panelPos, value: 1) {}
            CharacterController.doctor.changeBalloonTexture(index: 1)
            CharacterController.doctor.moveWithScaling(to: doctorPos, value: doctorScale[2], duration: 2.0) {
                doctorSays(in: .MissEnemiesInstruction, value: EqRobLines.setSubLineForMissEnemiesInstruction(enemy: enemy, eqRob: gameScene.eqRob, eqRobVe: gameScene.selectionPanel.veLabel.text!))
            }
        } else {
            let panelPos = CGPoint(x: gameScene.size.width/2-gameScene.selectionPanel.texture!.size().width/2, y: enemyPos.y-65)
            let doctorPos = CGPoint(x: doctorOnPos[2].x, y: panelPos.y+doctorOnPos[2].y)
            gameScene.selectionPanel.setInstruction(enemyVe: enemy.variableExpressionString)
            gameScene.selectionPanel.moveWithScaling(to: panelPos, value: 1) {}
            CharacterController.doctor.changeBalloonTexture(index: 1)
            CharacterController.doctor.moveWithScaling(to: doctorPos, value: doctorScale[2], duration: 2.0) {
                doctorSays(in: .MissEnemiesInstruction, value: EqRobLines.setSubLineForMissEnemiesInstruction(enemy: enemy, eqRob: gameScene.eqRob, eqRobVe: gameScene.selectionPanel.veLabel.text!))
            }
        }
    }
    
    private static func instruction() {
        switch EqRobTouchController.state {
        case .DeadInstruction:
            if EqRobLines.curIndex == 0 {
                back(3)
            } else if EqRobLines.curIndex == 1 || EqRobLines.curIndex == 2 {
                doctorSays(in: .DestroyedInstruction, value: EqRobLines.setSubLineForDestroyedInstruction(enemy: instructedEnemy!, eqRob: gameScene.eqRob, eqRobVe: gameScene.selectionPanel.veLabel.text!))
                setDemoCalculation()
            } else {
                doctorSays(in: .DestroyedInstruction, value: EqRobLines.setSubLineForDestroyedInstruction(enemy: instructedEnemy!, eqRob: gameScene.eqRob, eqRobVe: gameScene.selectionPanel.veLabel.text!))
            }
            break;
        case .AliveInstruction:
            if EqRobLines.curIndex == 0 {
                back(3)
            } else if EqRobLines.curIndex == 1 {
                makeInsturctionForMiss(enemy: instructedEnemy!)
            } else if EqRobLines.curIndex == 2 || EqRobLines.curIndex == 3 {
                doctorSays(in: .MissEnemiesInstruction, value: EqRobLines.setSubLineForMissEnemiesInstruction(enemy: instructedEnemy!, eqRob: gameScene.eqRob, eqRobVe: gameScene.selectionPanel.veLabel.text!))
                setDemoCalculation()
            } else {
                doctorSays(in: .MissEnemiesInstruction, value: EqRobLines.setSubLineForMissEnemiesInstruction(enemy: instructedEnemy!, eqRob: gameScene.eqRob, eqRobVe: gameScene.selectionPanel.veLabel.text!))
            }
            break;
        default:
            break;
        }
    }
    
    private static func resetAll() {
        selectedEnemyIndex = 0
        attackingEnemyIndex = 0
        selectedEnemies = [Enemy]()
        lines = [SKShapeNode]()
        EqRobTouchController.state = .Ready
        isPerfect = false
        gameScene.selectionPanel.againButton.isHidden = false
    }
    
    private static func allDone() {
        selectedEnemyIndex = 0
        attackingEnemyIndex = 0
        selectedEnemies = [Enemy]()
        lines = [SKShapeNode]()
        if EqRobTouchController.state == .DeadInstruction {
            EqRobTouchController.state = .Dead
            gameScene.eqRob.turn = gameScene.eqRob.deadTurnIndex
            gameScene.eqRob.wasDead = true
        } else  {
            EqRobTouchController.state = .Charging
            gameScene.eqRob.turn = gameScene.eqRob.chargingTurnIndex
            gameScene.eqRob.wasDead = false
        }
        isPerfect = false
        instructedEnemy?.removePointing()
        gameScene.selectionPanel.resetInstruction()
        CharacterController.doctor.setScale(1)
        CharacterController.doctor.balloon.isHidden = true
        CharacterController.doctor.move(from: nil, to: doctorOffPos)
        gameScene.eqRob.position = eqRobOriginPos
        gameScene.itemType = .None
        CharacterController.doctor.changeBalloonTexture(index: 0)
        ItemTouchController.othersTouched()
    }
    
    private static func tellCharging() {
        comeAndTell()
        doctorSays(in: .Charging, value: nil)
    }
    
    private static func tellChargeDone() {
        comeAndTell()
        doctorSays(in: .ChargeDone, value: nil)
        let wait = SKAction.wait(forDuration: 3.0)
        gameScene.run(wait, completion: {
            EqRobTouchController.state = .Ready
            goBack()
        })
    }
    
    private static func tellReborn() {
        comeAndTell()
        doctorSays(in: .Reborn, value: nil)
        gameScene.eqRob.isHidden = false
        let wait = SKAction.wait(forDuration: 3.0)
        gameScene.run(wait, completion: {
            EqRobTouchController.state = .Ready
            goBack()
        })
    }
    
    private static func comeAndTell() {
        CharacterController.doctor.setScale(doctorScale[0])
        CharacterController.doctor.balloon.isHidden = false
        CharacterController.doctor.move(from: doctorOffPos, to: doctorOnPos[0])
    }
    
    private static func goBack() {
        CharacterController.doctor.setScale(1)
        CharacterController.doctor.balloon.isHidden = true
        CharacterController.doctor.move(from: nil, to: doctorOffPos)
    }
    
    private static func showInputPanel() {
       gameScene.inputPanel.isHidden = false
    }
    
    private static func hideInputPanel() {
        gameScene.inputPanel.isHidden = true
    }
    
    private static func showSelectionPanel() {
        gameScene.selectionPanel.isHidden = false
    }
    
    private static func hideSelectionPanel() {
        gameScene.selectionPanel.isHidden = true
    }
    
    private static func doctorSays(in state: EqRobLinesState, value: String?) {
        EqRobLines.getLines(state: state, value: value).DAMultilined() { line in
            CharacterController.doctor.balloon.setLines(with: line)
        }
    }
    
    private static func drawLine(start: CGPoint, end: CGPoint) {
        let line = Line(startPoint: start, endPoint: end)
        lines.append(line)
        gameScene.addChild(line)
    }
    
}

enum EqRobState {
    case Ready, Pending, Attack, Attacking, DeadInstruction, AliveInstruction, Dead, Charging
}

struct EqRobTouchController {
    
    public static var state: EqRobState = .Ready
    
    public static func onEvent() {
        switch state {
        case .Ready:
            EqRobController.execute(0, enemy: nil)
            state = .Pending
            break;
        case .Attack:
            guard EqRobController.selectedEnemies.count > 0 else { return }
            EqRobController.execute(3, enemy: nil)
            state = .Attacking
            break;
        case .Charging:
            EqRobController.execute(5, enemy: nil)
            break;
        default:
            break;
        }
    }
}

enum EqRobLinesState {
    case WillInput, WillSelectEnemies, SelectingEnemies, WarnSelection, EqRobGo, EqRobDestroyed, DestroyedInstruction, MissEnemies, MissEnemiesInstruction, PerfectKill, Charging, ChargeDone, Reborn
}

struct EqRobLines {
    static func getLines(state: EqRobLinesState, value: String?) -> String {
        switch state {
        case .WillInput:
            return "ã¨ã¯ã­ãã«æå­å¼ãå¥åããã®ããï¼"
        case .WillSelectEnemies:
            return value! + "ã¨åãæå­å¼ãæã¤æµãé¸ã¶ã®ããï¼"
        case .SelectingEnemies:
            return subLineRandom(lines: subLinesForSelecting)
        case .WarnSelection:
            return "ãã¾ã¬!\n8ä½ã¾ã§ããé¸æã§ããã®ãã"
        case .EqRobGo:
            return "ã¨ã¯ã­ã çºé²ããï¼"
        case .EqRobDestroyed:
            return "ããã...\nã©ãããé¸æãã¹ãã¦ãã¾ã£ãããããã®"
        case .DestroyedInstruction:
            return value!
        case .MissEnemies:
            return "ãããã£ããï¼\nããããã¾ã åããæµã¯ããããããã®ã"
        case .MissEnemiesInstruction:
            return value!
        case .PerfectKill:
            return "ãã¼ãã§ã¯ãããï¼ï¼\nãããããã®ã"
        case .Charging:
            return "ã¨ã¯ã­ãã¯ãã¾ã ãã£ã¼ã¸ä¸­ãã"
        case .ChargeDone:
            return "ãã£ã¼ã¸å®äºããï¼ï¼"
        case .Reborn:
            return "ä¿®çå®äºãã\nããå£ããªãããã«é ¼ããï¼"
        default:
            return ""
        }
    }
    
    static var selectedLine = ""
    static let subLinesForSelecting: [String] = [
        "ã¨ã¯ã­ããã¿ããããã°ãé¸æããæµãã¡ã«åãã£ã¦çºé²ããã",
        "ããç´ãããæã¯ãä¸ã®ããç´ããã¿ã³ãæ¼ãã®ãã",
        "xã®æ°ã«é¢ä¿ãªããè¨ç®ãããåãã«ãªãæå­å¼ãé¸ã¶ã®ãã",
        "è¦ãç®ã«é¨ãããã§ãªãããè¨ç®ãã¦åããªãã°ãåãæå­å¼ãªã®ãã"
    ]
    
    static var curIndex = 0
    static func setSubLineForDestroyedInstruction(enemy: Enemy, eqRob: EqRob, eqRobVe: String) -> String {
        if curIndex == 1 || curIndex == 2 {
            let value = demo(enemy: enemy, eqRob: eqRob, eqRobVe: eqRobVe)
            return subLinesForDestroyedInstruction(value: value)
        } else {
            let value = "\(eqRobVe)ã¨\(enemy.variableExpressionString)"
            return subLinesForDestroyedInstruction(value: value)
        }
    }
    
    static func subLinesForDestroyedInstruction(value: String) -> String {
        switch curIndex {
        case 0:
            curIndex += 1
            return value + "ãæ¬å½ã«éãæå­å¼ãªã®ãç¢ºãããã"
        case 1:
            curIndex += 1
            return "ä¾ãã°" + value
        case 2:
            curIndex += 1
            return "ä»ã«ã" + value
        case 3:
            curIndex += 1
            return "ãã®ããã«ãåãxã®å¤ã§ãè¨ç®çµæãéãæå­å¼ã¯ãç°ãªãæå­å¼ãªã®ãã"
        case 4:
            curIndex = 0
            return "æ¬¡ãããééããªãããã«æ°ãã¤ãããããã"
        default:
            return ""
        }
    }
    
    static func setSubLineForMissEnemiesInstruction(enemy: Enemy, eqRob: EqRob, eqRobVe: String) -> String {
        if curIndex == 0 {
            let value = eqRobVe
            return subLinesForMissEnemiesInstruction(value: value)
        } else if curIndex == 1 {
            let value = "\(eqRobVe)ã¨\(enemy.variableExpressionString)"
            return subLinesForMissEnemiesInstruction(value: value)
        } else if curIndex == 2 || curIndex == 3 {
            let value = demo(enemy: enemy, eqRob: eqRob, eqRobVe: eqRobVe)
            return subLinesForMissEnemiesInstruction(value: value)
        } else {
            return subLinesForMissEnemiesInstruction(value: "")
        }
    }
    
    static func subLinesForMissEnemiesInstruction(value: String) -> String {
        switch curIndex {
        case 0:
            curIndex += 1
            return value + "ãè¦éãã¦ãã¾ã£ãæµãã"
        case 1:
            curIndex += 1
            return value + "ãæ¬å½ã«åãæå­å¼ãªã®ãç¢ºãããã"
        case 2:
            curIndex += 1
            return "ä¾ãã°" + value
        case 3:
            curIndex += 1
            return "ä»ã«ã" + value
        case 4:
            curIndex += 1
            return "ãã®ããã«ãåãxã®å¤ã§ãè¨ç®çµæãåãæå­å¼ã¯ãåç­ã®æå­å¼ãªã®ãã"
        case 5:
            curIndex = 0
            return "æ¬¡ã¯ããã¼ãã§ã¯ããç®æãã®ããï¼"
        default:
            return ""
        }
    }
    
    static var selectedRand = 0
    static let randArray = [1, 2, 3, 4, 5, 6, 7, 8, 9]
    static func demo(enemy: Enemy, eqRob: EqRob, eqRobVe: String) -> String {
        let cand = randArray.filter { $0 != selectedRand }
        let rand = arc4random_uniform(UInt32(cand.count))
        selectedRand = cand[Int(rand)]
        let valueOfEnemy = VECategory.calculateValue(veCategory: enemy.vECategory, value: selectedRand)
        let valueOfEqRob = VECategory.calculateValue(veCategory: eqRob.veCategory, value: selectedRand)
        print("\(selectedRand), \(valueOfEqRob), \(valueOfEnemy)")
        if valueOfEnemy == valueOfEqRob {
            return "x=\(selectedRand)ã®ã¨ãã\(eqRobVe)ã¯\(valueOfEqRob)ã\(enemy.variableExpressionString)ã¯\(valueOfEnemy)ã§åãå¤ã«ãªãããã"
        } else {
            return "x=\(selectedRand)ã®ã¨ãã\(eqRobVe)ã¯\(valueOfEqRob)ã\(enemy.variableExpressionString)ã¯\(valueOfEnemy)ã§éãå¤ã«ãªãããã"
        }
    }
    
    static func subLineOrder(lines: [String]) -> String {
        if let index = lines.index(of: selectedLine) {
            if index < lines.count-1 {
                selectedLine = lines[index+1]
                return selectedLine
            } else {
                selectedLine = ""
                return selectedLine
            }
        } else {
            selectedLine = lines[0]
            return selectedLine
        }
    }
    
    static func subLineRandom(lines: [String]) -> String {
        let otherLines = lines.filter { $0 != selectedLine }
        let index = arc4random_uniform(UInt32(otherLines.count))
        selectedLine = otherLines[Int(index)]
        return selectedLine
    }
}
